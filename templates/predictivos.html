<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHI - Aplicativos Predictivos</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">
    <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000000;
            color: white;
            font-family: 'Arial', sans-serif;
        }

        #aiBackground {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: linear-gradient(125deg, #000c0a 0%, #001a1c 28%, #001a0f 58%, #000e03 100%);
            overflow: hidden;
        }
        
        /* Estrellas de fondo */
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        .star {
            position: absolute;
            background-color: #ffffff;
            border-radius: 50%;
            opacity: 0.8;
            animation: twinkle 5s infinite ease-in-out;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 1; }
        }
        
        /* Nebulosas de fondo */
        .nebula {
            position: absolute;
            border-radius: 50%;
            filter: blur(40px);
            opacity: 0.15;
            background: radial-gradient(circle at center, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
            animation: pulse 15s infinite ease-in-out;
            pointer-events: none;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.1; transform: scale(1); }
            50% { opacity: 0.2; transform: scale(1.1); }
        }

        #particleCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 20%, rgba(0,0,0,0.4) 100%);
        }

        .app-menu {
            position: fixed;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 20;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            max-height: 95vh;
            overflow-y: auto;
            padding-right: 5px;
        }

        .app-card {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(33, 150, 243, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            pointer-events: auto;
            max-width: 280px;
            box-shadow: 0 0 15px rgba(33, 150, 243, 0.3);
            position: relative;
            overflow: hidden;
        }

        .app-card:hover {
            transform: translateX(-10px) scale(1.03);
            background: rgba(0, 0, 0, 0.7);
            border-color: rgba(33, 150, 243, 0.8);
            box-shadow: 0 0 20px rgba(33, 150, 243, 0.6);
        }

        /* Efecto de borde brillante al hacer hover */
        .app-card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 16px;
            background: linear-gradient(45deg, 
                transparent 25%, 
                rgba(0, 255, 140, 0.3) 50%, 
                transparent 75%);
            z-index: -1;
            transform: scale(0.98);
            opacity: 0;
            transition: all 0.5s ease-in-out;
        }

        .app-card:hover::before {
            opacity: 1;
            transform: scale(1.03);
            animation: borderRotate 3s linear infinite;
        }

        @keyframes borderRotate {
            0% {
                background-position: 0% 0%;
            }
            100% {
                background-position: 360% 0%;
            }
        }
        
        /* Efecto de partículas en el hover */
        .app-card .card-particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .app-card:hover .card-particles {
            opacity: 1;
        }
        
        .card-particle {
            position: absolute;
            background-color: #00ff9d;
            border-radius: 50%;
            opacity: 0;
            pointer-events: none;
        }
        
        /* Efecto de ondas al hacer clic */
        .app-card .ripple {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(0, 255, 140, 0.4);
            transform: scale(0);
            animation: rippleEffect 0.8s linear;
            pointer-events: none;
        }
        
        @keyframes rippleEffect {
            to {
                transform: scale(2.5);
                opacity: 0;
            }
        }
        
        /* Animación para iconos */
        .app-card:hover i {
            animation: iconPulse 1.5s infinite alternate;
        }
        
        @keyframes iconPulse {
            0% {
                transform: scale(1);
                text-shadow: 0 0 10px currentColor;
            }
            100% {
                transform: scale(1.1);
                text-shadow: 0 0 20px currentColor, 0 0 30px currentColor;
            }
        }

        .title-container {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10;
            padding: 15px;
            animation: fadeIn 1s ease forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .main-title {
            font-size: 2em;
            font-weight: bold;
            margin: 0;
            position: relative;
            overflow: visible;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        /* Reemplazar efecto elegante por un diseño de título holográfico futurista */
        .holographic-title {
            position: relative;
            color: white;
            text-shadow: 
                0 0 5px rgba(0, 255, 128, 0.8),
                0 0 10px rgba(0, 255, 128, 0.5),
                0 0 15px rgba(0, 255, 128, 0.3);
            background: rgba(0, 0, 0, 0.4);
            padding: 15px 30px;
            border-radius: 8px;
            border: 2px solid rgba(0, 255, 128, 0.3);
            box-shadow: 
                0 0 10px rgba(0, 255, 128, 0.2),
                inset 0 0 15px rgba(0, 255, 128, 0.1);
            z-index: 5;
        }
        
        /* Efecto de escaneado horizontal para el título */
        .holographic-title::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(0, 255, 128, 0.2),
                rgba(0, 255, 128, 0.4),
                rgba(0, 255, 128, 0.2),
                transparent
            );
            animation: scan-title 4s linear infinite;
            z-index: 10;
        }
        
        @keyframes scan-title {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        /* Efecto de líneas para el título */
        .title-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 128, 0.05) 2px,
                rgba(0, 255, 128, 0.05) 4px
            );
            opacity: 0.7;
            z-index: 1;
        }
        
        /* Destellos del título */
        .title-flicker {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            opacity: 0;
            background: rgba(0, 255, 128, 0.1);
            animation: title-flicker 6s linear infinite;
        }
        
        @keyframes title-flicker {
            0%, 92%, 94%, 96%, 98%, 100% { opacity: 0; }
            93%, 95%, 97%, 99% { opacity: 1; }
        }
        
        /* Borde brillante alrededor del título */
        .title-glow-border {
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border: 1px solid rgba(0, 255, 128, 0.5);
            border-radius: 10px;
            z-index: 1;
            filter: blur(2px);
            opacity: 0.7;
            animation: glow-pulse 2s ease-in-out infinite;
        }
        
        @keyframes glow-pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        /* Eliminar estilos anteriores que ya no se necesitan */
        .elegant-title {
            position: relative;
            font-weight: bold;
            color: white;
            z-index: 15;
        }
        
        /* Panel de resplandor detrás del título - ya no se usa */
        .title-glow {
            display: none;
        }
        
        /* Efectos adicionales para el título */
        .elegant-title::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg, 
                rgba(0, 255, 128, 0.3),
                rgba(0, 204, 102, 0.1) 25%, 
                rgba(0, 255, 128, 0.3) 50%, 
                rgba(0, 204, 102, 0.1) 75%, 
                rgba(0, 255, 128, 0.3)
            );
            filter: blur(8px);
            z-index: -1;
            opacity: 0.6;
            animation: pulse-glow 4s ease-in-out infinite;
        }
        
        @keyframes pulse-glow {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }
        
        @keyframes gradient-shift {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }
        
        /* Borde con brillo */
        .elegant-title::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ff80, transparent);
            animation: border-pulse 3s ease-in-out infinite;
        }
        
        @keyframes border-pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        /* Efecto glitch para título - REEMPLAZADO */
        .glitch-effect {
            position: relative;
            display: inline-block;
        }
        
        .subtitle {
            font-size: 1em;
            margin-top: 3px;
            opacity: 0;
            transform: translateX(-20px);
            animation: fadeInRight 0.8s ease forwards 0.5s;
            background: linear-gradient(45deg, #cccccc, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        @keyframes fadeInRight {
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .back-button {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(33, 150, 243, 0.5);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            pointer-events: auto;
            box-shadow: 0 0 10px rgba(33, 150, 243, 0.3);
        }

        .back-button:hover {
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(33, 150, 243, 0.5);
        }

        /* Mensajes de estado/error */
        #errorMsg {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 0, 0, 0.3);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            z-index: 100;
            display: none;
        }
        
        /* Efecto de código binario en el fondo */
        .binary-code {
            position: fixed;
            z-index: 3;
            color: rgba(0, 210, 102, 0.6);
            font-family: monospace;
            font-size: 16px;
            font-weight: bold;
            pointer-events: none;
            text-shadow: 0 0 8px rgba(0, 255, 128, 0.7);
            white-space: nowrap;
            letter-spacing: 2px;
            opacity: 0.8;
            transition: color 0.3s ease, transform 0.3s ease;
        }

        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            background: radial-gradient(
                ellipse at center,
                transparent 0%,
                rgba(0, 90, 30, 0.1) 70%,
                rgba(0, 90, 30, 0.2) 100%
            );
            pointer-events: none;
        }

        /* Panel de insights IA */
        .ai-insights {
            position: fixed;
            left: 20px;
            bottom: 20px;
            z-index: 10;
            pointer-events: none;
        }
        
        .insight-panel {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 128, 0.5);
            border-radius: 10px;
            padding: 15px;
            width: 280px;
            color: white;
            box-shadow: 0 0 20px rgba(0, 255, 128, 0.3);
            overflow: hidden;
            animation: panel-glow 3s infinite alternate;
        }
        
        @keyframes panel-glow {
            0% { box-shadow: 0 0 20px rgba(0, 255, 128, 0.3); }
            100% { box-shadow: 0 0 25px rgba(0, 255, 128, 0.5); }
        }
        
        .insight-title {
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #00ff80;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(0, 255, 128, 0.5);
        }
        
        .insight-data {
            font-size: 0.8em;
        }
        
        .data-point {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            border-bottom: 1px solid rgba(0, 255, 128, 0.2);
            padding-bottom: 4px;
        }
        
        .data-label {
            color: rgba(255, 255, 255, 0.7);
        }
        
        .data-value {
            color: #00ff80;
            font-weight: bold;
        }
        
        .data-progress {
            margin-top: 10px;
            height: 3px;
            background: rgba(0, 255, 128, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00ff80, #00b359);
            animation: progress-animation 15s infinite;
        }
        
        @keyframes progress-animation {
            0% { width: 20%; }
            20% { width: 40%; }
            50% { width: 60%; }
            70% { width: 80%; }
            90% { width: 90%; }
            100% { width: 25%; }
        }

        /* Efecto de líneas de escaneo más pronunciadas */
        .scan-effect {
            position: fixed;
            pointer-events: none;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 19;
            background: repeating-linear-gradient(
                to bottom,
                transparent 0%,
                rgba(0, 30, 10, 0.05) 0.5%,
                transparent 1%
            );
            opacity: 0.3;
            background-size: 100% 4px;
        }

        .scan-line {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100px;
            z-index: 19;
            background: linear-gradient(
                to bottom,
                transparent 0%,
                rgba(0, 255, 120, 0.1) 50%,
                transparent 100%
            );
            opacity: 0.1;
            pointer-events: none;
            animation: scanline 8s linear infinite;
        }

        @keyframes scanline {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100vh); }
        }

        /* Efecto de tecleo para texto */
        .typewriter {
            overflow: hidden;
            border-right: 3px solid #00ff80;
            white-space: nowrap;
            animation: 
                typing 3.5s steps(40, end),
                blink-caret 0.75s step-end infinite;
            margin: 0 auto;
        }

        @keyframes typing {
            from { width: 0 }
            to { width: 100% }
        }

        @keyframes blink-caret {
            from, to { border-color: transparent }
            50% { border-color: #00ff80 }
        }
        
        /* Efecto de código decodificado */
        .decoded-text {
            position: relative;
            color: #00ff80;
            font-family: monospace;
            display: inline-block;
        }
        
        .decoded-text::before {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            color: #00ff80;
            overflow: hidden;
            animation: decode 1s steps(30) forwards;
            white-space: nowrap;
        }
        
        @keyframes decode {
            0% { width: 0; }
            100% { width: 100%; }
        }
        
        /* Loading terminal */
        .terminal-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #00ff80;
            border-radius: 5px;
            padding: 20px;
            font-family: monospace;
            color: #00ff80;
            box-shadow: 0 0 30px rgba(0, 255, 128, 0.3);
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        .terminal-container.visible {
            opacity: 1;
        }
        
        .terminal-header {
            border-bottom: 1px solid #00ff80;
            padding-bottom: 10px;
            margin-bottom: 10px;
            font-size: 16px;
            color: #fff;
        }
        
        .terminal-content {
            height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .terminal-line {
            margin-bottom: 5px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .terminal-line.visible {
            opacity: 1;
        }
        
        .terminal-prompt {
            color: #fff;
        }
        
        .terminal-command {
            color: #00ff80;
        }
        
        .terminal-result {
            color: #aaa;
            padding-left: 20px;
        }
        
        .terminal-error {
            color: #ff5050;
        }
        
        .terminal-success {
            color: #00ffaa;
        }
        
        .terminal-progress {
            height: 2px;
            width: 100%;
            background: rgba(0, 255, 128, 0.2);
            margin-top: 10px;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .terminal-progress-bar {
            height: 100%;
            width: 0;
            background: #00ff80;
            transition: width 0.3s ease;
        }
        
        /* Efecto de transición de página */
        .page-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 9999;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .page-transition.active {
            opacity: 1;
        }
        
        .transition-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #00ff80;
            font-family: monospace;
            font-size: 24px;
        }
        
        .loading-dots {
            display: inline-block;
            width: 80px;
            text-align: left;
        }
        
        .loading-dots:after {
            content: '.';
            animation: dots 1.5s steps(5, end) infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60% { content: '...'; }
            80%, 100% { content: ''; }
        }
        
        /* Cursor hexagonal alrededor del ratón */
        .hex-cursor {
            position: fixed;
            width: 40px;
            height: 40px;
            border: 2px solid rgba(0, 255, 128, 0.5);
            border-radius: 0;
            transform: rotate(45deg);
            pointer-events: none;
            z-index: 9999;
            transition: all 0.1s ease;
            opacity: 0.7;
            mix-blend-mode: screen;
        }
        
        .hex-cursor::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border: 1px solid rgba(0, 255, 128, 0.3);
            transform: rotate(45deg);
        }

        /* Botón Acerca de - REDISEÑADO */
        .about-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: rgba(0, 50, 20, 0.9);
            border: 2px solid rgba(0, 255, 128, 0.9);
            border-radius: 50%;
            z-index: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            pointer-events: auto;
            box-shadow: 0 0 15px rgba(0, 255, 128, 0.5);
            animation: pulse-button 2s infinite alternate;
        }
        
        @keyframes pulse-button {
            0% { transform: scale(1); box-shadow: 0 0 15px rgba(0, 255, 128, 0.5); }
            100% { transform: scale(1.1); box-shadow: 0 0 25px rgba(0, 255, 128, 0.7); }
        }
        
        .about-button:hover {
            transform: scale(1.2) !important;
            box-shadow: 0 0 25px rgba(0, 255, 128, 0.9) !important;
        }
        
        .about-button i {
            font-size: 24px;
            color: rgba(0, 255, 128, 1);
            text-shadow: 0 0 10px rgba(0, 255, 128, 0.8);
        }
        
        /* Modal Acerca de - MEJORADO */
        .about-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            z-index: 9000;
            display: none; /* Cambiado de flex a none inicialmente */
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }
        
        .about-modal.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .about-content {
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(0, 255, 128, 0.5);
            border-radius: 15px;
            padding: 30px;
            color: white;
            position: relative;
            box-shadow: 0 0 30px rgba(0, 255, 128, 0.3);
            transform: translateY(30px);
            transition: transform 0.4s ease;
        }
        
        .about-modal.visible .about-content {
            transform: translateY(0);
        }
        
        .about-header {
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(0, 255, 128, 0.3);
            padding-bottom: 10px;
        }
        
        .about-title {
            font-size: 1.8em;
            margin-bottom: 5px;
            color: #00ff80;
        }
        
        .about-subtitle {
            font-size: 1em;
            color: #e6e6e6;
        }
        
        .about-section {
            margin-bottom: 20px;
        }
        
        .about-section-title {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #00ff80;
        }
        
        .about-close {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 128, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .about-close:hover {
            background: rgba(50, 50, 50, 0.7);
        }
        
        .about-feature {
            display: flex;
            margin-bottom: 10px;
        }
        
        .about-feature-icon {
            flex: 0 0 40px;
            height: 40px;
            margin-right: 15px;
            background: rgba(0, 255, 128, 0.2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #00ff80;
        }
        
        .about-feature-content {
            flex: 1;
        }
        
        .about-feature-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #e6e6e6;
        }
    </style>
</head>
<body>
    <div id="aiBackground"></div>
    <div id="stars" class="stars"></div>
    <canvas id="particleCanvas"></canvas>
    
    <div class="scan-effect"></div>
    <div class="scan-line"></div>
    <div class="hex-cursor" id="hexCursor"></div>
    
    <div class="page-transition" id="pageTransition">
        <div class="transition-content">
            <span class="decoded-text" data-text="CARGANDO SISTEMA">CARGANDO SISTEMA</span>
            <span class="loading-dots"></span>
        </div>
    </div>
    
    <div class="terminal-container" id="terminalContainer">
        <div class="terminal-header">PHI :: Sistema de Análisis Predictivo</div>
        <div class="terminal-content" id="terminalContent">
            <!-- Terminal lines will be added here -->
        </div>
        <div class="terminal-progress">
            <div class="terminal-progress-bar" id="terminalProgressBar"></div>
        </div>
    </div>
    
    <div class="overlay">
        <div class="title-container">
            <h1 class="main-title">
                <div class="holographic-title">
                    <div class="title-lines"></div>
                    <div class="title-flicker"></div>
                    <div class="title-glow-border"></div>
                    <span class="elegant-title">Aplicativos Predictivos PHI</span>
                </div>
            </h1>
            <p class="subtitle typewriter">Inteligencia Artificial y Modelos Predictivos</p>
        </div>

        <div class="back-button" onclick="window.location.href='/'">
            <i class="fas fa-home"></i>
        </div>
    </div>

    <div class="app-menu">
        <div class="app-card" data-aos="fade-left" data-aos-delay="100" onclick="window.location.href='/predictivos/asistentes'">
            <div class="card-particles"></div>
            <i class="fas fa-robot fa-2x mb-3" style="color: #00e780;"></i>
            <h5>Predicción de Asistencia</h5>
            <p>Modelos de predicción para estimar número de asistentes a actividades comunitarias del Proyecto Hidroituango</p>
        </div>
        
        <div class="app-card" data-aos="fade-left" data-aos-delay="200" onclick="window.location.href='/predictivos/temporal'">
            <div class="card-particles"></div>
            <i class="fas fa-chart-line fa-2x mb-3" style="color: #00cc66;"></i>
            <h5>Análisis Temporal</h5>
            <p>Análisis de series temporales para identificar tendencias y patrones en actividades del Proyecto Hidroituango</p>
        </div>

        <div class="app-card" data-aos="fade-left" data-aos-delay="300" onclick="window.location.href='/predictivos/geografico'">
            <div class="card-particles"></div>
            <i class="fas fa-globe-americas fa-2x mb-3" style="color: #00ff80;"></i>
            <h5>Análisis Geográfico</h5>
            <p>Visualización y análisis predictivo de la distribución geográfica de actividades del Proyecto Hidroituango</p>
        </div>
        
        <div class="app-card" data-aos="fade-left" data-aos-delay="400" onclick="window.location.href='/geoportal'">
            <div class="card-particles"></div>
            <i class="fas fa-map-marked-alt fa-2x mb-3" style="color: #33cc99;"></i>
            <h5>Geoportal</h5>
            <p>Visualización avanzada de datos geoespaciales relacionados con actividades y comunidades del Proyecto Hidroituango</p>
        </div>
    </div>
    
    <!-- Botón Acerca de -->
    <div class="about-button" id="aboutButton" onclick="showModal()">
        <i class="fas fa-info"></i>
    </div>
    
    <!-- Modal Acerca de -->
    <div class="about-modal" id="aboutModal">
        <div class="about-content">
            <div class="about-close" id="aboutClose" onclick="hideModal()">
                <i class="fas fa-times" style="color: #00ff80;"></i>
            </div>
            
            <div class="about-header">
                <h2 class="about-title">Módulos Predictivos PHI</h2>
                <p class="about-subtitle">Plataforma avanzada de análisis y predicción basada en inteligencia artificial</p>
            </div>
            
            <div class="about-section">
                <h3 class="about-section-title">Acerca del Sistema</h3>
                <p>Los Módulos Predictivos PHI constituyen un componente avanzado del Sistema de Información Geográfica diseñado específicamente para el Proyecto Hidroituango. Esta suite de herramientas utiliza algoritmos de inteligencia artificial, aprendizaje automático y análisis estadístico para generar predicciones precisas, identificar patrones complejos y visualizar tendencias relacionadas con las actividades del proyecto.</p>
            </div>
            
            <div class="about-section">
                <h3 class="about-section-title">Tecnologías Implementadas</h3>
                <p>Los módulos predictivos se basan en una arquitectura de vanguardia que combina múltiples tecnologías:</p>
                <ul>
                    <li>Redes neuronales profundas para análisis de patrones complejos</li>
                    <li>Algoritmos de aprendizaje por refuerzo para optimización continua</li>
                    <li>Procesamiento de lenguaje natural para análisis de contexto</li>
                    <li>Técnicas avanzadas de visualización de datos</li>
                    <li>Integración con sistemas de información geográfica</li>
                    <li>Procesamiento distribuido para análisis en tiempo real</li>
                </ul>
            </div>
            
            <div class="about-section">
                <h3 class="about-section-title">Módulos Principales</h3>
                
                <div class="about-feature">
                    <div class="about-feature-icon">
                        <i class="fas fa-robot"></i>
                    </div>
                    <div class="about-feature-content">
                        <div class="about-feature-title">Predicción de Asistencia</div>
                        <p>Herramienta especializada que estima con alta precisión el número de participantes esperados en actividades comunitarias relacionadas con el Proyecto Hidroituango. El sistema analiza datos históricos, variables contextuales, factores estacionales y dinámicas sociales para generar proyecciones fiables que facilitan la planificación logística y la asignación de recursos.</p>
                    </div>
                </div>
                
                <div class="about-feature">
                    <div class="about-feature-icon">
                        <i class="fas fa-chart-line"></i>
                    </div>
                    <div class="about-feature-content">
                        <div class="about-feature-title">Análisis Temporal</div>
                        <p>Módulo dedicado al procesamiento de series temporales que identifica patrones cíclicos, tendencias de largo plazo y anomalías en los datos relacionados con las actividades del proyecto. Esta herramienta permite visualizar la evolución histórica de indicadores clave, prever comportamientos futuros y detectar cambios significativos que requieran atención.</p>
                    </div>
                </div>
                
                <div class="about-feature">
                    <div class="about-feature-icon">
                        <i class="fas fa-globe-americas"></i>
                    </div>
                    <div class="about-feature-content">
                        <div class="about-feature-title">Análisis Geográfico</div>
                        <p>Sistema de visualización y análisis espacial que mapea la distribución geográfica de actividades y recursos del proyecto. Esta herramienta permite identificar clusters, hotspots y patrones de dispersión, facilitando la toma de decisiones territoriales y la optimización de la cobertura geográfica de las iniciativas.</p>
                    </div>
                </div>
                
                <div class="about-feature">
                    <div class="about-feature-icon">
                        <i class="fas fa-map-marked-alt"></i>
                    </div>
                    <div class="about-feature-content">
                        <div class="about-feature-title">Geoportal Integrado</div>
                        <p>Interfaz avanzada para la visualización de capas geoespaciales que integra datos satelitales, cartografía base, límites administrativos y variables temáticas. Esta plataforma permite realizar análisis espaciales complejos y generar mapas dinámicos que representan visualmente los distintos aspectos del proyecto y su relación con el territorio.</p>
                    </div>
                </div>
            </div>
            
            <div class="about-section">
                <h3 class="about-section-title">Beneficios Clave</h3>
                <ul>
                    <li>Anticipación de tendencias y comportamientos futuros</li>
                    <li>Optimización en la asignación de recursos humanos y materiales</li>
                    <li>Mejora en la planificación de actividades comunitarias</li>
                    <li>Identificación temprana de áreas de atención prioritaria</li>
                    <li>Visualización intuitiva de datos complejos para facilitar la toma de decisiones</li>
                    <li>Análisis automatizado de grandes volúmenes de datos históricos</li>
                    <li>Monitoreo en tiempo real de indicadores críticos</li>
                </ul>
            </div>
            
            <div class="about-section">
                <h3 class="about-section-title">Capacidades Analíticas</h3>
                <p>El sistema implementa múltiples técnicas analíticas avanzadas:</p>
                <ul>
                    <li>Modelos predictivos de serie temporal (ARIMA, Prophet, RNN)</li>
                    <li>Análisis de regresión multivariable</li>
                    <li>Algoritmos de clustering espacial (K-means, DBSCAN)</li>
                    <li>Análisis de densidad Kernel para identificación de hotspots</li>
                    <li>Redes bayesianas para modelado de incertidumbre</li>
                    <li>Técnicas de optimización multiobjetivo</li>
                    <li>Análisis de sentimiento y minería de texto</li>
                </ul>
            </div>
        </div>
    </div>

    <div id="errorMsg"></div>

    <div class="ai-insights">
        <div class="insight-panel">
            <div class="insight-title">Análisis en tiempo real</div>
            <div class="insight-data">
                <div class="data-point">
                    <span class="data-label">Precisión del modelo:</span>
                    <span class="data-value counter">97.5</span><span>%</span>
                </div>
                <div class="data-point">
                    <span class="data-label">Nodos activos:</span>
                    <span class="data-value counter">1,457</span>
                </div>
                <div class="data-point">
                    <span class="data-label">Estado:</span>
                    <span class="data-value">Operativo</span>
                </div>
                <div class="data-progress">
                    <div class="progress-bar"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuración de las partículas
        let particleCanvas, particleCtx;
        let particles = [];
        let lastTime = 0;
        
        // Efecto de código binario
        const binaryStrings = [];
        
        // Inicialización
        document.addEventListener('DOMContentLoaded', () => {
            // Mostrar transición de página
            showPageTransition();
            
            // Crear estrellas para el fondo
            createStars();
            
            // Crear nebulosas para el fondo
            createNebulas();
            
            // Inicializar partículas
            initParticles();
            
            // Inicializar efecto binario
            initBinaryCode();
            
            // Inicializar efectos de partículas en tarjetas
            initCardParticles();
            
            // Añadir evento de clic para efectos de ondas
            document.querySelectorAll('.app-card').forEach(card => {
                card.addEventListener('click', createRippleEffect);
            });
            
            // Inicializar AOS para animaciones
            AOS.init({
                duration: 1000,
                once: false,
                mirror: true,
                offset: 0,
                delay: 50
            });
            
            // Manejar eventos de mouse para interactividad
            window.addEventListener('mousemove', handleMouseMove);
            
            // Manejar redimensionamiento
            window.addEventListener('resize', handleResize);
            
            // Asegurar que los elementos AOS sean visibles
            setTimeout(() => {
                document.querySelectorAll('.app-card').forEach(card => {
                    card.classList.add('aos-animate');
                });
            }, 500);
            
            // Cursor hexagonal
            initHexCursor();
            
            // Inicializar eventos adicionales para el modal
            initModalEvents();
        });
        
        // Efecto de transición de página
        function showPageTransition() {
            const transition = document.getElementById('pageTransition');
            transition.classList.add('active');
            
            // Simular carga
            setTimeout(() => {
                // Mostrar terminal
                showTerminal();
                
                setTimeout(() => {
                    // Ocultar transición
                    transition.classList.remove('active');
                    
                    // Ocultar terminal después de que termina
                    setTimeout(() => {
                        const terminal = document.getElementById('terminalContainer');
                        terminal.style.opacity = '0';
                        setTimeout(() => {
                            terminal.style.display = 'none';
                        }, 500);
                    }, 4000);
                }, 3000);
            }, 1000);
        }
        
        // Mostrar terminal con comandos
        function showTerminal() {
            const terminal = document.getElementById('terminalContainer');
            const content = document.getElementById('terminalContent');
            const progressBar = document.getElementById('terminalProgressBar');
            
            // Mostrar terminal
            terminal.classList.add('visible');
            
            // Comandos y resultados
            const commands = [
                { type: 'prompt', text: '$ ' },
                { type: 'command', text: 'iniciar_sistema_phi' },
                { type: 'result', text: 'Inicializando módulos del sistema...' },
                { type: 'result', text: 'Cargando recursos gráficos...' },
                { type: 'result', text: 'Estableciendo conexiones con bases de datos...' },
                { type: 'result', text: 'Verificando integridad de modelos predictivos...' },
                { type: 'success', text: 'Todos los modelos cargados correctamente.' },
                { type: 'prompt', text: '$ ' },
                { type: 'command', text: 'cargar_interfaz --modo=interactivo' },
                { type: 'result', text: 'Renderizando interfaz de usuario...' },
                { type: 'result', text: 'Aplicando efectos visuales...' },
                { type: 'success', text: 'Sistema listo. Bienvenido a Predictivos PHI.' }
            ];
            
            // Mostrar comandos secuencialmente
            let i = 0;
            let progress = 0;
            
            const addLine = () => {
                if (i >= commands.length) return;
                
                const line = document.createElement('div');
                line.className = 'terminal-line';
                
                if (commands[i].type === 'prompt') {
                    line.innerHTML = `<span class="terminal-prompt">${commands[i].text}</span>`;
                } else if (commands[i].type === 'command') {
                    line.innerHTML = `<span class="terminal-command">${commands[i].text}</span>`;
                } else if (commands[i].type === 'error') {
                    line.innerHTML = `<span class="terminal-error">${commands[i].text}</span>`;
                } else if (commands[i].type === 'success') {
                    line.innerHTML = `<span class="terminal-success">${commands[i].text}</span>`;
                } else {
                    line.innerHTML = `<span class="terminal-result">${commands[i].text}</span>`;
                }
                
                content.appendChild(line);
                
                // Scroll al final
                content.scrollTop = content.scrollHeight;
                
                // Mostrar línea con fade
                setTimeout(() => {
                    line.classList.add('visible');
                }, 50);
                
                // Actualizar progreso
                progress += (100 / commands.length);
                progressBar.style.width = `${progress}%`;
                
                i++;
                
                // Continuar con la siguiente línea
                if (i < commands.length) {
                    setTimeout(addLine, commands[i-1].type === 'command' ? 500 : 300);
                }
            };
            
            // Iniciar secuencia
            setTimeout(addLine, 300);
        }
        
        // Inicializar cursor hexagonal
        function initHexCursor() {
            const cursor = document.getElementById('hexCursor');
            
            document.addEventListener('mousemove', e => {
                cursor.style.left = `${e.clientX}px`;
                cursor.style.top = `${e.clientY}px`;
            });
            
            // Escala cuando está cerca de los botones
            document.addEventListener('mousemove', e => {
                let overInteractive = false;
                
                document.querySelectorAll('.app-card, .back-button').forEach(el => {
                    const rect = el.getBoundingClientRect();
                    const isNear = 
                        e.clientX >= rect.left - 50 && 
                        e.clientX <= rect.right + 50 && 
                        e.clientY >= rect.top - 50 && 
                        e.clientY <= rect.bottom + 50;
                    
                    if (isNear) {
                        overInteractive = true;
                    }
                });
                
                if (overInteractive) {
                    cursor.style.transform = 'rotate(45deg) scale(1.2)';
                    cursor.style.borderColor = 'rgba(0, 255, 128, 0.8)';
                } else {
                    cursor.style.transform = 'rotate(45deg) scale(1)';
                    cursor.style.borderColor = 'rgba(0, 255, 128, 0.5)';
                }
            });
        }
        
        // Crear estrellas para el fondo
        function createStars() {
            const starsContainer = document.getElementById('stars');
            const starsCount = 250; // Aumentado para más densidad
            
            for (let i = 0; i < starsCount; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                
                // Tamaño aleatorio
                const size = Math.random() * 3 + 1; // Tamaño aumentado
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                
                // Posición aleatoria
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                
                // Brillo aleatorio
                star.style.opacity = Math.random() * 0.8 + 0.2;
                
                // Animación con retraso aleatorio
                star.style.animationDelay = `${Math.random() * 5}s`;
                
                // Color aleatorio (predominantemente blanco y verde)
                const colors = [
                    'rgba(255, 255, 255, 0.9)',    // Blanco
                    'rgba(200, 255, 220, 0.9)',    // Verde claro
                    'rgba(180, 255, 200, 0.9)',    // Verde pálido
                    'rgba(220, 255, 220, 0.9)',    // Verde blanquecino
                ];
                star.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                
                // Añadir atributo para el efecto de parallax
                star.setAttribute('data-depth', Math.random());
                
                starsContainer.appendChild(star);
            }
            
            // Efecto parallax para las estrellas
            document.addEventListener('mousemove', (e) => {
                const mouseX = e.clientX / window.innerWidth;
                const mouseY = e.clientY / window.innerHeight;
                
                const stars = document.querySelectorAll('.star');
                stars.forEach(star => {
                    const depth = parseFloat(star.getAttribute('data-depth'));
                    const moveX = (mouseX - 0.5) * 50 * depth;
                    const moveY = (mouseY - 0.5) * 50 * depth;
                    
                    star.style.transform = `translate(${moveX}px, ${moveY}px)`;
                });
            });
            
            // Añadir movimiento automático cuando no hay interacción
            let lastActivity = Date.now();
            
            document.addEventListener('mousemove', () => {
                lastActivity = Date.now();
            });
            
            // Mover automáticamente las estrellas
            function autoMoveStars() {
                // Si han pasado más de 3 segundos sin actividad
                if (Date.now() - lastActivity > 3000) {
                    const time = Date.now() * 0.001;
                    const autoMoveX = Math.sin(time) * 0.5;
                    const autoMoveY = Math.cos(time) * 0.5;
                    
                    const stars = document.querySelectorAll('.star');
                    stars.forEach(star => {
                        const depth = parseFloat(star.getAttribute('data-depth'));
                        const moveX = autoMoveX * 50 * depth;
                        const moveY = autoMoveY * 50 * depth;
                        
                        star.style.transform = `translate(${moveX}px, ${moveY}px)`;
                    });
                }
                
                requestAnimationFrame(autoMoveStars);
            }
            
            // Iniciar movimiento automático
            autoMoveStars();
        }
        
        // Crear nebulosas para el fondo
        function createNebulas() {
            const starsContainer = document.getElementById('stars');
            const nebulasCount = 5;
            
            // Colores para las nebulosas
            const nebulaColors = [
                'rgba(0, 231, 128, 0.2)',    // Verde Matrix
                'rgba(0, 200, 102, 0.2)',    // Verde medio
                'rgba(0, 255, 128, 0.2)',    // Verde brillante
                'rgba(51, 204, 153, 0.2)',   // Verde azulado
                'rgba(0, 179, 89, 0.2)',     // Verde bosque
                'rgba(0, 220, 153, 0.2)',    // Verde turquesa
                'rgba(0, 170, 85, 0.2)',     // Verde jade
                'rgba(0, 230, 115, 0.2)'     // Verde luz
            ];
            
            for (let i = 0; i < nebulasCount; i++) {
                const nebula = document.createElement('div');
                nebula.className = 'nebula';
                
                // Tamaño aleatorio
                const size = Math.random() * 300 + 200;
                nebula.style.width = `${size}px`;
                nebula.style.height = `${size}px`;
                
                // Posición aleatoria
                nebula.style.left = `${Math.random() * 100}%`;
                nebula.style.top = `${Math.random() * 100}%`;
                
                // Color aleatorio
                nebula.style.background = `radial-gradient(circle at center, ${nebulaColors[Math.floor(Math.random() * nebulaColors.length)]} 0%, rgba(0,0,0,0) 70%)`;
                
                // Animación con retraso aleatorio
                nebula.style.animationDelay = `${Math.random() * 10}s`;
                
                starsContainer.appendChild(nebula);
            }
        }
        
        // Inicializar partículas
        function initParticles() {
            particleCanvas = document.getElementById('particleCanvas');
            particleCtx = particleCanvas.getContext('2d');
            
            // Configurar tamaño del canvas
            resizeCanvas();
            
            // Crear partículas
            createParticles();
            
            // Iniciar animación
            requestAnimationFrame(animateParticles);
        }
        
        // Redimensionar canvas
        function resizeCanvas() {
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;
        }
        
        // Manejar redimensionamiento de ventana
        function handleResize() {
            resizeCanvas();
            createParticles(); // Recrear partículas para la nueva dimensión
        }
        
        // Crear partículas
        function createParticles() {
            particles = [];
            const particleCount = Math.min(window.innerWidth, window.innerHeight) * 0.1;
            
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: Math.random() * particleCanvas.width,
                    y: Math.random() * particleCanvas.height,
                    size: Math.random() * 4 + 2,
                    speedX: (Math.random() - 0.5) * 0.3,
                    speedY: (Math.random() - 0.5) * 0.3,
                    color: getRandomColor(),
                    opacity: Math.random() * 0.7 + 0.3,
                    connections: [],
                    pulse: Math.random() * 100
                });
            }
        }
        
        // Obtener color aleatorio para las partículas
        function getRandomColor() {
            const colors = [
                '#00e780', // Verde Matrix
                '#00cc66', // Verde medio
                '#00ff80', // Verde brillante
                '#33cc99', // Verde azulado
                '#00b359', // Verde bosque
                '#00fa9a', // Verde primavera
                '#00dd99', // Aqua verde
                '#00e599', // Verde menta
                '#1aff66', // Verde neón
                '#00cc99', // Verde turquesa
                '#00aa55', // Verde jade
                '#00ffbf', // Verde agua clara
                '#00e673', // Verde luz
                '#39ff14', // Verde hacker
                '#00ff9d', // Verde fósforo
                '#00c957', // Verde esmeralda
                '#00a36c', // Verde teal
                '#00d38a'  // Verde terminal
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        // Dibujar partículas
        function drawParticles(time) {
            // Limpiar canvas
            particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
            
            // Encontrar las conexiones entre partículas
            findConnections();
            
            // Dibujar conexiones
            drawConnections();
            
            // Dibujar las partículas
            particles.forEach(particle => {
                // Efecto de brillo
                const glow = 20 * particle.size * (0.5 + particle.opacity * 0.5);
                
                // Dibujar halo/resplandor
                const gradient = particleCtx.createRadialGradient(
                    particle.x, particle.y, 0,
                    particle.x, particle.y, glow
                );
                gradient.addColorStop(0, particle.color + 'AA');
                gradient.addColorStop(1, particle.color + '00');
                
                particleCtx.beginPath();
                particleCtx.arc(particle.x, particle.y, glow, 0, Math.PI * 2);
                particleCtx.fillStyle = gradient;
                particleCtx.fill();
                
                // Dibujar el núcleo de la partícula
                particleCtx.beginPath();
                particleCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                particleCtx.fillStyle = particle.color + Math.floor(particle.opacity * 255).toString(16).padStart(2, '0');
                particleCtx.fill();
            });
        }
        
        // Animar partículas
        function animateParticles(time) {
            const deltaTime = time - lastTime;
            lastTime = time;
            
            // Actualizar posiciones
            particles.forEach(particle => {
                particle.x += particle.speedX;
                particle.y += particle.speedY;
                
                // Verificar límites
                if (particle.x < 0 || particle.x > particleCanvas.width) {
                    particle.speedX = -particle.speedX;
                }
                if (particle.y < 0 || particle.y > particleCanvas.height) {
                    particle.speedY = -particle.speedY;
                }
                
                // Efecto de pulso de opacidad y tamaño
                particle.pulse += 0.01 + Math.random() * 0.02;
                const pulseFactor = (Math.sin(particle.pulse) + 1) * 0.5;
                particle.opacity = 0.3 + pulseFactor * 0.5;
                particle.displaySize = particle.size * (0.8 + pulseFactor * 0.4);
            });
            
            // Dibujar
            drawParticles(time);
            
            // Continuar animación
            requestAnimationFrame(animateParticles);
        }
        
        // Encontrar conexiones entre partículas cercanas
        function findConnections() {
            const maxDistance = 200;
            
            particles.forEach(p => {
                p.connections = [];
            });
            
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < maxDistance) {
                        // Guardar conexión
                        particles[i].connections.push({
                            particle: particles[j],
                            distance: distance,
                            opacity: 1 - (distance / maxDistance)
                        });
                    }
                }
            }
        }
        
        // Dibujar conexiones entre partículas
        function drawConnections() {
            particles.forEach(particle => {
                particle.connections.forEach(connection => {
                    particleCtx.beginPath();
                    particleCtx.moveTo(particle.x, particle.y);
                    particleCtx.lineTo(connection.particle.x, connection.particle.y);
                    
                    // Gradiente de color para las conexiones
                    const gradient = particleCtx.createLinearGradient(
                        particle.x, particle.y, 
                        connection.particle.x, connection.particle.y
                    );
                    
                    // Aumentar opacidad de los enlaces
                    const opacity = Math.min(connection.opacity * 1.8, 1.0);
                    gradient.addColorStop(0, particle.color + Math.floor(opacity * 190).toString(16).padStart(2, '0'));
                    gradient.addColorStop(1, connection.particle.color + Math.floor(opacity * 190).toString(16).padStart(2, '0'));
                    
                    particleCtx.strokeStyle = gradient;
                    particleCtx.lineWidth = 1.8;
                    particleCtx.stroke();
                    
                    // Añadir efecto de "data flow" a lo largo de la línea
                    if (Math.random() > 0.95) {
                        const t = Math.random();
                        const x = particle.x * (1 - t) + connection.particle.x * t;
                        const y = particle.y * (1 - t) + connection.particle.y * t;
                        
                        particleCtx.beginPath();
                        particleCtx.arc(x, y, 2.2, 0, Math.PI * 2);
                        particleCtx.fillStyle = '#ffffff';
                        particleCtx.fill();
                    }
                });
            });
        }
        
        // Manejar movimiento del mouse
        function handleMouseMove(event) {
            const mouseX = event.clientX;
            const mouseY = event.clientY;
            
            // Afectar a partículas cercanas al ratón
            particles.forEach(particle => {
                const dx = mouseX - particle.x;
                const dy = mouseY - particle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 180) {
                    // Efecto de atracción/repulsión
                    const angle = Math.atan2(dy, dx);
                    let force;
                    
                    // Distancia media para cambiar de repulsión a atracción
                    if (distance < 80) {
                        // Repeler cuando está muy cerca
                        force = (80 - distance) / 200;
                        particle.speedX -= Math.cos(angle) * force;
                        particle.speedY -= Math.sin(angle) * force;
                        
                        // Aumentar tamaño y brillo cuando está cerca
                        particle.size = Math.min(particle.size * 1.05, particle.size * 2.5);
                        particle.opacity = Math.min(particle.opacity * 1.1, 1);
                    } else {
                        // Atraer ligeramente cuando está a media distancia
                        force = (distance - 80) / 800;
                        particle.speedX += Math.cos(angle) * force;
                        particle.speedY += Math.sin(angle) * force;
                    }
                    
                    // Limitar velocidad
                    const speed = Math.sqrt(particle.speedX * particle.speedX + particle.speedY * particle.speedY);
                    if (speed > 4) {
                        particle.speedX = (particle.speedX / speed) * 4;
                        particle.speedY = (particle.speedY / speed) * 4;
                    }
                    
                    // Añadir un efecto visual al interactuar
                    if (Math.random() > 0.9) {
                        // Crear un pequeño destello en la partícula
                        const flash = document.createElement('div');
                        flash.style.position = 'absolute';
                        flash.style.left = `${particle.x}px`;
                        flash.style.top = `${particle.y}px`;
                        flash.style.width = `${particle.size * 4}px`;
                        flash.style.height = `${particle.size * 4}px`;
                        flash.style.borderRadius = '50%';
                        flash.style.backgroundColor = particle.color;
                        flash.style.boxShadow = `0 0 20px ${particle.color}`;
                        flash.style.opacity = '0.8';
                        flash.style.zIndex = '4';
                        flash.style.transform = 'translate(-50%, -50%)';
                        flash.style.transition = 'all 0.3s ease-out';
                        flash.style.pointerEvents = 'none';
                        
                        document.body.appendChild(flash);
                        
                        // Animar y eliminar el destello
                        setTimeout(() => {
                            flash.style.opacity = '0';
                            flash.style.width = `${particle.size * 10}px`;
                            flash.style.height = `${particle.size * 10}px`;
                            
                            setTimeout(() => {
                                document.body.removeChild(flash);
                            }, 300);
                        }, 10);
                    }
                }
            });
            
            // Interactuar con códigos binarios cercanos
            binaryStrings.forEach(stream => {
                const streamRect = stream.getBoundingClientRect();
                const streamX = streamRect.left + streamRect.width / 2;
                const streamY = streamRect.top + streamRect.height / 2;
                
                const dx = mouseX - streamX;
                const dy = mouseY - streamY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 150) {
                    // Cambiar color y hacer efecto visual
                    const intensity = 1 - (distance / 150);
                    
                    // Generar un nuevo color basado en la distancia
                    const r = Math.floor(0 + intensity * 20);
                    const g = Math.floor(170 + intensity * 85);
                    const b = Math.floor(50 + intensity * 50);
                    
                    stream.style.color = `rgba(${r}, ${g}, ${b}, ${0.6 + intensity * 0.4})`;
                    stream.style.textShadow = `0 0 ${8 + intensity * 12}px rgba(${r}, ${g}, ${b}, ${0.7 + intensity * 0.3})`;
                    
                    // Efecto de repulsión ligero
                    const angle = Math.atan2(dy, dx);
                    const moveX = Math.cos(angle) * (10 * intensity);
                    const moveY = Math.sin(angle) * (10 * intensity);
                    
                    stream.style.transform = `translate(${moveX}px, ${moveY}px)`;
                    
                    // Regenerar código binario al pasar cerca
                    if (Math.random() > 0.7) {
                        stream.textContent = generateBinaryString(10 + Math.floor(Math.random() * 30));
                    }
                } else {
                    // Restablecer transformación cuando no hay interacción
                    stream.style.transform = 'translate(0, 0)';
                }
            });
            
            // Crear un efecto de seguimiento del cursor
            if (Math.random() > 0.1) {
                const cursorParticle = document.createElement('div');
                cursorParticle.style.position = 'absolute';
                cursorParticle.style.left = `${mouseX}px`;
                cursorParticle.style.top = `${mouseY}px`;
                cursorParticle.style.width = `${3 + Math.random() * 7}px`;
                cursorParticle.style.height = `${3 + Math.random() * 7}px`;
                cursorParticle.style.borderRadius = '50%';
                cursorParticle.style.backgroundColor = getRandomColor();
                cursorParticle.style.opacity = '0.7';
                cursorParticle.style.zIndex = '4';
                cursorParticle.style.transform = 'translate(-50%, -50%)';
                cursorParticle.style.transition = 'all 0.5s ease-out';
                cursorParticle.style.pointerEvents = 'none';
                
                document.body.appendChild(cursorParticle);
                
                // Animar y eliminar
                setTimeout(() => {
                    cursorParticle.style.opacity = '0';
                    cursorParticle.style.width = '20px';
                    cursorParticle.style.height = '20px';
                    
                    setTimeout(() => {
                        document.body.removeChild(cursorParticle);
                    }, 500);
                }, 10);
            }
        }
        
        // Inicializar efecto de código binario
        function initBinaryCode() {
            const streamCount = 40;
            
            for (let i = 0; i < streamCount; i++) {
                createBinaryStream();
            }
            
            // Iniciar animación de streams binarios
            animateBinaryStreams();
            
            // Iniciar efecto de decodificación Matrix avanzada
            enhancedMatrixEffect();
        }
        
        // Crear una corriente de código binario
        function createBinaryStream() {
            const stream = document.createElement('div');
            stream.className = 'binary-code';
            
            // Determinar dirección aleatoria (0: arriba, 1: derecha, 2: abajo, 3: izquierda)
            const direction = Math.floor(Math.random() * 4);
            
            // Posición inicial basada en la dirección
            let x, y;
            
            switch(direction) {
                case 0: // Desde arriba
                    x = Math.random() * window.innerWidth;
                    y = -100;
                    break;
                case 1: // Desde la derecha
                    x = window.innerWidth + 100;
                    y = Math.random() * window.innerHeight;
                    break;
                case 2: // Desde abajo
                    x = Math.random() * window.innerWidth;
                    y = window.innerHeight + 100;
                    break;
                case 3: // Desde la izquierda
                    x = -100;
                    y = Math.random() * window.innerHeight;
                    break;
            }
            
            stream.style.left = `${x}px`;
            stream.style.top = `${y}px`;
            
            // Añadir un color aleatorio con más intensidad
            const colors = [
                'rgba(0, 231, 128, 0.8)',  // Verde Matrix
                'rgba(0, 200, 102, 0.8)',  // Verde medio
                'rgba(0, 255, 128, 0.8)',  // Verde brillante
                'rgba(51, 204, 153, 0.8)', // Verde azulado
                'rgba(0, 179, 89, 0.8)',   // Verde bosque
                'rgba(0, 220, 153, 0.8)',  // Verde turquesa
                'rgba(57, 255, 20, 0.8)',  // Verde hacker
                'rgba(0, 255, 157, 0.8)'   // Verde fósforo
            ];
            stream.style.color = colors[Math.floor(Math.random() * colors.length)];
            
            // Añadir sombra del mismo color pero más brillante
            const color = stream.style.color.replace('0.8', '0.9');
            stream.style.textShadow = `0 0 10px ${color}`;
            
            // Tamaño aleatorio
            const size = 14 + Math.floor(Math.random() * 8);
            stream.style.fontSize = `${size}px`;
            
            // Contenido: cadena binaria
            stream.textContent = generateBinaryString(10 + Math.floor(Math.random() * 30));
            
            // Velocidad (ajustada a un poco más rápida)
            stream.speed = 0.5 + Math.random() * 1.5;
            
            // Guardar dirección de movimiento
            stream.direction = direction;
            
            // Ángulo para direcciones diagonales (opcional, por si quieres variación)
            if (Math.random() > 0.7) {
                stream.angle = Math.random() * 0.5 - 0.25; // Desviación pequeña del ángulo principal
            } else {
                stream.angle = 0;
            }
            
            // Añadir a la página y al array
            document.body.appendChild(stream);
            binaryStrings.push(stream);
        }
        
        // Generar cadena binaria aleatoria
        function generateBinaryString(length) {
            let result = '';
            // Más unos que ceros para un efecto más llamativo
            for (let i = 0; i < length; i++) {
                result += Math.random() > 0.25 ? '1' : '0';
            }
            return result;
        }
        
        // Animar las corrientes binarias
        function animateBinaryStreams() {
            binaryStrings.forEach((stream, index) => {
                // Obtener posición actual
                const left = parseFloat(stream.style.left) || 0;
                const top = parseFloat(stream.style.top) || 0;
                
                // Mover según dirección
                let newLeft = left;
                let newTop = top;
                
                switch(stream.direction) {
                    case 0: // Desde arriba - baja
                        newTop = top + stream.speed;
                        newLeft = left + Math.sin(stream.angle || 0) * stream.speed;
                        break;
                    case 1: // Desde la derecha - va a la izquierda
                        newLeft = left - stream.speed;
                        newTop = top + Math.sin(stream.angle || 0) * stream.speed;
                        break;
                    case 2: // Desde abajo - sube
                        newTop = top - stream.speed;
                        newLeft = left + Math.sin(stream.angle || 0) * stream.speed;
                        break;
                    case 3: // Desde la izquierda - va a la derecha
                        newLeft = left + stream.speed;
                        newTop = top + Math.sin(stream.angle || 0) * stream.speed;
                        break;
                }
                
                // Actualizar posición
                stream.style.left = `${newLeft}px`;
                stream.style.top = `${newTop}px`;
                
                // Comprobar si está fuera de la pantalla
                const isOutOfBounds = 
                    newLeft < -300 || 
                    newLeft > window.innerWidth + 300 || 
                    newTop < -300 || 
                    newTop > window.innerHeight + 300;
                
                // Regenerar si sale de la pantalla
                if (isOutOfBounds) {
                    // Eliminar elemento antiguo del DOM
                    stream.remove();
                    
                    // Eliminar del array
                    binaryStrings.splice(index, 1);
                }
            });
            
            // Crear más streams para mantener cierta cantidad
            if (binaryStrings.length < 30) {
                if (Math.random() > 0.9) {
                    createBinaryStream();
                }
            }
            
            // Usar timeout para controlar la velocidad de animación
            setTimeout(() => {
                requestAnimationFrame(animateBinaryStreams);
            }, 25);
        }

        // Animación avanzada de Matrix con "decoding"
        function enhancedMatrixEffect() {
            // Ocasionalmente "decodifica" parte del código binario a texto
            setInterval(() => {
                const codeElements = document.querySelectorAll('.binary-code');
                if (Math.random() > 0.7 && codeElements.length > 0) {
                    const randomElement = codeElements[Math.floor(Math.random() * codeElements.length)];
                    const originalText = randomElement.textContent;
                    
                    // Frases de "decode"
                    const decodeTexts = [
                        "PREDICCIÓN COMPLETA",
                        "ANÁLISIS EXITOSO",
                        "PATRÓN DETECTADO",
                        "ANOMALÍA ENCONTRADA",
                        "SECUENCIA VALIDADA",
                        "PROYECTO HIDROITUANGO",
                        "SIMULACIÓN INICIADA"
                    ];
                    
                    // Efecto de decodificación
                    const decodeText = decodeTexts[Math.floor(Math.random() * decodeTexts.length)];
                    let currentText = originalText;
                    let progress = 0;
                    
                    const decodeStep = setInterval(() => {
                        progress += 0.1;
                        let newText = '';
                        
                        for (let i = 0; i < originalText.length; i++) {
                            if (i < decodeText.length && Math.random() < progress) {
                                newText += decodeText[i];
                            } else {
                                newText += (Math.random() > 0.5) ? '0' : '1';
                            }
                        }
                        
                        randomElement.textContent = newText;
                        randomElement.style.color = 'rgba(0, 255, 140, 1)';
                        randomElement.style.textShadow = '0 0 15px rgba(0, 255, 140, 0.9)';
                        
                        if (progress >= 1) {
                            clearInterval(decodeStep);
                            
                            // Volver al binario después de mostrar el mensaje
                            setTimeout(() => {
                                randomElement.textContent = generateBinaryString(originalText.length);
                                randomElement.style.color = '';
                                randomElement.style.textShadow = '';
                            }, 2000);
                        }
                    }, 50);
                }
            }, 5000);
            
            // Animar contadores en el panel de insights
            animateCounters();
        }
        
        // Animar contadores
        function animateCounters() {
            const counters = document.querySelectorAll('.counter');
            
            counters.forEach(counter => {
                const target = parseFloat(counter.textContent.replace(/,/g, ''));
                const duration = 2000; // milisegundos
                const steps = 30;
                const stepDuration = duration / steps;
                let current = 0;
                
                const updateCounter = setInterval(() => {
                    current += target / steps;
                    
                    if (current >= target) {
                        current = target;
                        clearInterval(updateCounter);
                    }
                    
                    // Formatear con comas para miles
                    counter.textContent = current.toLocaleString('en-US', {
                        minimumFractionDigits: counter.textContent.includes('.') ? 1 : 0,
                        maximumFractionDigits: counter.textContent.includes('.') ? 1 : 0
                    });
                }, stepDuration);
            });
            
            // Repetir la animación periódicamente
            setTimeout(animateCounters, 15000);
        }

        // Inicializar partículas de tarjetas
        function initCardParticles() {
            document.querySelectorAll('.card-particles').forEach(container => {
                // Crear partículas iniciales
                for (let i = 0; i < 15; i++) {
                    createCardParticle(container);
                }
                
                // Animar partículas continuamente
                animateCardParticles(container);
            });
        }
        
        // Crear una partícula para la tarjeta
        function createCardParticle(container) {
            const particle = document.createElement('div');
            particle.className = 'card-particle';
            
            // Posición aleatoria dentro del contenedor
            const x = Math.random() * 100;
            const y = Math.random() * 100;
            particle.style.left = `${x}%`;
            particle.style.top = `${y}%`;
            
            // Tamaño aleatorio
            const size = Math.random() * 6 + 2;
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            
            // Color aleatorio entre verde y cian
            const hue = 140 + Math.random() * 40;
            particle.style.backgroundColor = `hsla(${hue}, 100%, 70%, 0.8)`;
            
            // Añadir información para animación
            particle.dataset.directionX = Math.random() * 2 - 1;
            particle.dataset.directionY = Math.random() * 2 - 1;
            particle.dataset.speed = 0.2 + Math.random() * 0.3;
            
            // Añadir al contenedor
            container.appendChild(particle);
            
            return particle;
        }
        
        // Animar partículas de tarjetas
        function animateCardParticles(container) {
            const particles = container.querySelectorAll('.card-particle');
            const rect = container.getBoundingClientRect();
            
            particles.forEach(particle => {
                // Solo animar si la tarjeta está en hover
                if (container.parentElement.matches(':hover')) {
                    // Obtener posición actual
                    let x = parseFloat(particle.style.left) || 0;
                    let y = parseFloat(particle.style.top) || 0;
                    
                    // Mover partícula
                    x += parseFloat(particle.dataset.directionX) * parseFloat(particle.dataset.speed);
                    y += parseFloat(particle.dataset.directionY) * parseFloat(particle.dataset.speed);
                    
                    // Comprobar límites
                    if (x < 0 || x > 100) {
                        particle.dataset.directionX = -parseFloat(particle.dataset.directionX);
                    }
                    if (y < 0 || y > 100) {
                        particle.dataset.directionY = -parseFloat(particle.dataset.directionY);
                    }
                    
                    // Actualizar posición
                    particle.style.left = `${x}%`;
                    particle.style.top = `${y}%`;
                    
                    // Mostrar partícula con animación
                    if (parseFloat(particle.style.opacity || 0) < 0.8) {
                        particle.style.opacity = Math.min(parseFloat(particle.style.opacity || 0) + 0.05, 0.8);
                    }
                } else {
                    // Ocultar partícula gradualmente
                    if (parseFloat(particle.style.opacity || 0) > 0) {
                        particle.style.opacity = Math.max(parseFloat(particle.style.opacity || 0) - 0.05, 0);
                    }
                }
            });
            
            requestAnimationFrame(() => animateCardParticles(container));
        }
        
        // Crear efecto de ondas al hacer clic
        function createRippleEffect(event) {
            const card = this;
            
            // Eliminar cualquier efecto previo
            const existingRipples = card.querySelectorAll('.ripple');
            existingRipples.forEach(ripple => {
                ripple.remove();
            });
            
            // Crear nuevo efecto
            const ripple = document.createElement('div');
            ripple.className = 'ripple';
            
            // Posicionar el efecto donde ocurrió el clic
            const rect = card.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Tamaño debe ser al menos el ancho o alto del elemento
            const maxDim = Math.max(rect.width, rect.height);
            const rippleSize = maxDim * 2;
            
            ripple.style.width = ripple.style.height = `${rippleSize}px`;
            ripple.style.left = `${x - rippleSize/2}px`;
            ripple.style.top = `${y - rippleSize/2}px`;
            
            card.appendChild(ripple);
            
            // Eliminar el efecto después de la animación
            setTimeout(() => {
                ripple.remove();
            }, 800);
            
            // No detener el evento de clic para que siga funcionando la navegación
        }

        // Funciones globales para mostrar/ocultar el modal
        function showModal() {
            const modal = document.getElementById('aboutModal');
            if (!modal) return;
            
            console.log("Mostrando modal mediante función global");
            modal.style.display = 'flex';
            
            // Pequeño retraso para permitir que se aplique el display: flex antes de añadir la clase
            setTimeout(() => {
                modal.classList.add('visible');
                modal.style.opacity = '1';
                modal.style.pointerEvents = 'auto';
            }, 10);
        }
        
        function hideModal() {
            const modal = document.getElementById('aboutModal');
            if (!modal) return;
            
            console.log("Ocultando modal mediante función global");
            modal.classList.remove('visible');
            modal.style.opacity = '0';
            modal.style.pointerEvents = 'none';
            
            // Esperar a que termine la transición antes de ocultar
            setTimeout(() => {
                modal.style.display = 'none';
            }, 400);
        }

        // Inicializar eventos adicionales para el modal
        function initModalEvents() {
            const aboutModal = document.getElementById('aboutModal');
            
            // Cerrar al hacer clic fuera del contenido
            if (aboutModal) {
                aboutModal.addEventListener('click', function(e) {
                    if (e.target === aboutModal) {
                        hideModal();
                    }
                });
            }
            
            // Cerrar con tecla Escape
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    hideModal();
                }
            });
            
            // También podemos asegurarnos que el botón sea interactivo
            const aboutButton = document.getElementById('aboutButton');
            if (aboutButton) {
                aboutButton.style.cursor = 'pointer';
                aboutButton.style.pointerEvents = 'auto';
            }
        }
    </script>
</body>
</html> 